package io.Depth_Unknown.engine.physics;

import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes;
import com.badlogic.gdx.graphics.g3d.Model;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Quaternion;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.physics.bullet.Bullet;
import com.badlogic.gdx.physics.bullet.collision.*;
import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;
import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;
import com.badlogic.gdx.physics.bullet.dynamics.btSequentialImpulseConstraintSolver;
import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;
import io.Depth_Unknown.game.Game;
import io.Depth_Unknown.game.GameObject;

import java.util.HashMap;

public class PhysicsEngine implements GameObject {
    private final btBroadphaseInterface broadphase;
    private final btDiscreteDynamicsWorld world;
    private final btDefaultCollisionConfiguration collisionConfig;
    private final btCollisionDispatcher dispatcher;
    private final HashMap<Integer, PhysicsObject> physicsObjects;
    private final btSequentialImpulseConstraintSolver solver;

    public btDiscreteDynamicsWorld getWorld() {
        return world;
    }

    public PhysicsEngine() {
        Bullet.init();
        collisionConfig = new btDefaultCollisionConfiguration();
        dispatcher = new btCollisionDispatcher(collisionConfig);
        broadphase = new btDbvtBroadphase();
        solver = new btSequentialImpulseConstraintSolver();
        world = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfig);
        btGhostPairCallback ghostCallback = new btGhostPairCallback();
        world.getBroadphase().getOverlappingPairCache().setInternalGhostPairCallback(ghostCallback);

        physicsObjects = new HashMap<>();
        //world.addCollisionObject(physicsObjects.body);
        world.setGravity(new Vector3(0,-9.8f,0));
        //world.setGravity(new Vector3(0,0,0));

    }


    // This one is mostly generated by ChatGPT because I could not get built in methods to work, and I don't understand the math involved very well.
    public btCollisionShape getMapShape(Model model) {
        btTriangleMesh triangleMesh = new btTriangleMesh();

        for (Mesh mesh : model.meshes) {
            VertexAttribute posAttr = mesh.getVertexAttribute(VertexAttributes.Usage.Position);
            int stride = mesh.getVertexSize() / 4; // floats per vertex

            float[] vertices = new float[mesh.getNumVertices() * stride];
            mesh.getVertices(vertices);

            short[] indices = new short[mesh.getNumIndices()];
            mesh.getIndices(indices);

            Matrix4 zToY = new Matrix4().setToRotation(new Vector3(1, 0, 0), -90f); // Z-up â†’ Y-up

            for (int i = 0; i < indices.length; i += 3) {
                int i1 = indices[i] * stride + posAttr.offset / 4;
                int i2 = indices[i + 1] * stride + posAttr.offset / 4;
                int i3 = indices[i + 2] * stride + posAttr.offset / 4;

                Vector3 v1 = new Vector3(
                    vertices[i1], vertices[i1 + 1], vertices[i1 + 2]
                );
                Vector3 v2 = new Vector3(
                    vertices[i2], vertices[i2 + 1], vertices[i2 + 2]
                );
                Vector3 v3 = new Vector3(
                    vertices[i3], vertices[i3 + 1], vertices[i3 + 2]
                );
                Vector3 v1r = v1.cpy().rot(zToY);
                Vector3 v2r = v2.cpy().rot(zToY);
                Vector3 v3r = v3.cpy().rot(zToY);

                triangleMesh.addTriangle(v1r, v3r, v2r, true);
            }
        }
        btCollisionShape shape = new btBvhTriangleMeshShape(triangleMesh, true);
        shape.setMargin(0.08f); // increase slightly
        return shape;
    }

    /**
     * @param delta
     */
    @Override
    public void update(float delta) {
        if (!Game.isGamePaused()) {
            world.stepSimulation(delta, 5, 1f / 240f);
        }
    }

    /**
     *
     */
    @Override
    public void destroy() {

    }

    /**
     * @param deltaTime
     */
    @Override
    public void render(float deltaTime) {

    }

    public btRigidBody addRigidBody(btCollisionShape shape, Matrix4 transform, float mass) {
        Vector3 inertia = new Vector3();
        if (mass > 0f) {
            shape.calculateLocalInertia(mass, inertia);
        }
        btDefaultMotionState motionState = new btDefaultMotionState(transform);
        btRigidBody.btRigidBodyConstructionInfo info = new btRigidBody.btRigidBodyConstructionInfo(mass, motionState, shape, inertia);
        btRigidBody body = new btRigidBody(info);
        world.addRigidBody(body);

        // Dispose of Construction Info after use
        info.dispose();
        return body;
    }

    public btRigidBody addRigidBody(btRigidBody rigidBody) {
        world.addRigidBody(rigidBody);
        return rigidBody;
    }

    /**
     * This method is mostly ChatGPT generated as I don't understand CollisionFlags very well, or have time to figure it out
     * */
    public btRigidBody addKinematicBody(btCollisionShape shape, Matrix4 transform) {
        btRigidBody body = addStaticBody(shape, transform);
        int flags = body.getCollisionFlags();
        body.setCollisionFlags(flags | btCollisionObject.CollisionFlags.CF_KINEMATIC_OBJECT);
        body.setActivationState(Collision.DISABLE_DEACTIVATION);

        return body;
    }

    /**
     * This method is mostly ChatGPT generated as I don't understand CollisionFlags very well, or have time to figure it out
     * */
    public btGhostObject addTrigger(btCollisionShape shape, Matrix4 transform) {
        btGhostObject triggerObj = new btGhostObject();
        triggerObj.setCollisionShape(shape);
        triggerObj.setWorldTransform(transform);
        triggerObj.setCollisionFlags(triggerObj.getCollisionFlags() | btCollisionObject.CollisionFlags.CF_NO_CONTACT_RESPONSE);
        triggerObj.setActivationState(Collision.DISABLE_DEACTIVATION);
        world.addCollisionObject(triggerObj, btBroadphaseProxy.CollisionFilterGroups.SensorTrigger, btBroadphaseProxy.CollisionFilterGroups.AllFilter);
        return triggerObj;
    }

    public btRigidBody addStaticBody(btCollisionShape shape, Matrix4 transform) {
        return this.addRigidBody(shape, transform, 0f);
    }

    public void removeRigidBody(btRigidBody body) {
        world.removeRigidBody(body);
    }

    public boolean rayCast(Vector3 from, Vector3 to, ClosestRayResultCallback callback) {
        world.rayTest(from, to, callback);
        return callback.hasHit();
    }

    public static Vector3 rotatePointAroundY(Vector3 point, Vector3 center, float angleRad) {
        float cos = MathUtils.cos(angleRad);
        float sin = MathUtils.sin(angleRad);

        Vector3 p = point.cpy().sub(center);

        float x = p.x * cos - p.z * sin;
        float z = p.x * sin + p.z * cos;

        return new Vector3(x, p.y, z).add(center);
    }


}

